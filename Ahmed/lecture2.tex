\documentclass{article}
\usepackage{amsmath,amsthm,stmaryrd,amssymb}
\usepackage{mathpartir}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}{Definition}[theorem]
\newtheorem{example}{Example}

\newcommand{\pack}[4]{\texttt{pack}(#1,\ #2)\ \texttt{as}\ \exists#3.#4}
\newcommand{\unpack}[4]{\texttt{unpack}(#1,\ #2)=#3\ \texttt{in}\ #4}
\newcommand{\letin}[3]{\texttt{let}\ #1=#2\ \texttt{in}\ #3}
\newcommand{\ifzero}[3]{\texttt{if}0\ #1\ #2\ #3}

\title{Secure Compilation \\ \Large{Lecture 2}} 
\author{Renate Robin Eilers  \and Cristina Matache \and Baber Rehman}

\date{June 24, 2019}

\begin{document}

\maketitle

This is the second talk presented by Amal Ahmed in OPLSS 2019, University of Oregon, USA.

\section{Introduction}

\subsection{Source Language}

\subsubsection{Types}

We just have integers and functions in source language. \\

$\sigma$ ::= int \textbar \hspace{0.1cm} $\sigma_1$ $\rightarrow$ $\sigma_2 ::= $

\subsubsection{Terms}

\subsection{Target Language}

\section{Preservation Proof}

\begin{theorem}[Type Preservation]
If $\Gamma$ $\vdash$ $e_S$ : $\sigma$ and  $\Gamma$ $\vdash$ $e_S$ : $\alpha$ $\rightsquigarrow$ $e_T$ then $\Gamma_S^+$ $\vdash$ $e_T$ : $\sigma^+$
\end{theorem}

For correctness, we want to show $e_S$ $\approx$ $e_T$. This is not contexual equivalance because source language and target language are two different languages.
There are many ways to prove compiler correction. We want to say that when:
\begin{center}
 $e_S$ $\approx$ $e_T$ then $\sigma$ $\approx$ $\sigma^+$
\end{center}
V$\llbracket$ $\sigma$ $\rrbracket$  = \{  ($V_S$ , $V_T$) $\textbar$ . $\vdash$ $V_{S}$ : $\sigma$ $\wedge$ . ; . $\vdash$ $V_{T}$ : $\sigma^+$ ..... \} \\
V$\llbracket$ ints $\rrbracket$ = \{ ($n_S$ , $n_T$) \} \\
V$\llbracket$ $\sigma_1$ $\rightarrow$ $\sigma_2$ $\rrbracket$ = \{ ($\lambda$x:$\sigma_1$ . $e_S$ \}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
